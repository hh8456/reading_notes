         ;代码清单11-1
         ;文件名：c11_mbr.asm
         ;文件说明：硬盘主引导扇区代码 
         ;创建日期：2011-5-16 19:54

         ;设置堆栈段和栈指针 
         mov ax,cs      
		 ; // 栈段寄存器 SS 被初始化为 0x000
         mov ss,ax
		 ; // 实模式下,主引导程序的加载位置是 0x0000:0x7c00, 把栈指针寄存器指向 0x7c00
         mov sp,0x7c00
      
		;// 将 GDT 线性基地址低 16 位存放在 AX , 高16位存放在 DX
         ;计算GDT所在的逻辑段地址 
         mov ax,[cs:gdt_base+0x7c00]        ;低16位 
         mov dx,[cs:gdt_base+0x7c00+0x02]   ;高16位 
		 ; // 将 GDT 线性基地址转换成逻辑地址, 方法是 DX:AX / 16, 商是逻辑段地址(AX),余数是偏移地址(DX)
		 ; // 将逻辑段地址放在 DS 中,偏移地址放在 BX 中
         mov bx,16        
         div bx            
         mov ds,ax                          ;令DS指向该段以进行操作
         mov bx,dx                          ;段内起始偏移地址 
      
		;// 段描述符是 8 字节,应处理器要求,从段起始偏移地址开头出,8个字节要清零
         ;创建0#描述符，它是空描述符，这是处理器的要求
         mov dword [bx+0x00],0x00
         mov dword [bx+0x04],0x00  

		 ; // 参照 P188 页图 11-4, 段描述符解读:
		 ; // 在偏移地址 8 字节处,安装 #1 段描述符, 每个描述符用 8 字节(64位)表示, 低32位初始化为 0x7c0001ff, 高32位初始化为 0x00409800
		 ; // 0x7c0001ff 高16位 7c00 和 0x00409800 低 8 位 00, 表示32位段基址 0x007c00, 低16位 01ff 段界限
		 ; // 0x00409800 转换为二级制后 0000 0000 0100 0000 1001 1000 0000 0000, 下标从 0 开始计算, 第 12 位 = 1, 即 S 位=1, 表示属于存储器的段
		 ; // 第 23 位 = 1, 对于代码段此位(D/B) 是 D 位, D=1 表示是 32 位偏移地址或者操作数, 是个 32位的段
		 ; // 第 15 位 = 1, P位 = 1, 表示该段目前位于内存中
		 ; // 第14,13位 = 00, DPL位 = 00, 表示段的特权级别为 00
		 ; // 第 11 至 8 位 = 1000, TYPE 位 1000 表示这是一个只能执行的代码段
         ;创建#1描述符，保护模式下的代码段描述符
         mov dword [bx+0x08],0x7c0001ff     
         mov dword [bx+0x0c],0x00409800     

		 ; // 同上方法剖析出 #2 描述符的32位线性段基址是 0x000B8000, 即显存的起始地址
		 ; // 属于存储器的段, 在内存中,特权级 0, 
         ;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区） 
         mov dword [bx+0x10],0x8000ffff     
         mov dword [bx+0x14],0x0040920b     

		 ; // 同上方法剖析出 #3 描述符的32位线性段基址是 0x00000000, 段界限 0x07a00
         ;创建#3描述符，保护模式下的堆栈段描述符		 
         mov dword [bx+0x18],0x00007a00
		 ; // 安装完段 #3描述符后,偏移地址是 0x1c + 4字节 = 0x20
         mov dword [bx+0x1c],0x00409600

		 ; // 至此,安装了 4 个描述符, 共 4*8字节 = 32 字节 = 0x20,		 
		 ; // 把描述符表的界限值(下标从 0 开始计算, 第32个字节, 就是 31 ),保存在主引导扇区内存起始地址处前两个字节		 
         ;初始化描述符表寄存器GDTR
         mov word [cs: gdt_size+0x7c00],31  ;描述符表的界限（总字节数减一）   
                     
		; // 加载描述符标的线性基地址和界限到全局描述符表寄存器 GDTR
		; // 加载 6个字节到 GDTR; 因为 gdt_size 和 gdt_base 是连续声明,紧挨在一起, 所以就把两者(共6个字节)加载到了 GDTR
		; // 现在仍然处于保护模式下,所以指令偏移地址都要 + 0x7c00
         lgdt [cs: gdt_size+0x7c00]
      
		; // 端口 0x92 的位 1 用于打开 A20, 前者和来自键盘控制器的 A20 控制线一起,连接到处理器的 A20M 引脚
         in al,0x92                         ;南桥芯片内的端口 
         or al,0000_0010B
         out 0x92,al                        ;打开A20

		 ; // 处理器标志寄存器的中断标志位清0,不允许中断
         cli                                ;保护模式下中断机制尚未建立，应 
                                            ;禁止中断 
											
		; // 把处理器内部控制寄存器 CR0 第1位(位0)设置为 1, 保护模式允许位( Protection Enable, PE )
         mov eax,cr0
         or eax,1
         mov cr0,eax                        ;设置PE位
      
         ;以下进入保护模式... ...
		 ;// 在保护模式下, 0x0008 不是段地址,而是段选择子, 是 #1 (每个)描述符(8字节)对应着的代码段基址
		 ; // 0x007c00, 主引导程序的加载位置
         jmp dword 0x0008:flush             ;16位的描述符选择子：32位偏移
                                            ;清流水线并串行化处理器 
         [bits 32] 

		 ; // 实模式中的段寄存器,在保护模式下叫做段选择器; 保护模式的内存访问跟实模式不同,尽管访问内存时也需要指定一个段,
		 ; // 但传送到段选择器的内容不是逻辑段地址,而是段描述符在描述符表中的索引号, 段选择子
		 ; // 这里的段选择子是 16 ( 索引下标是从 0 开始计算 ), 表示 #2 (每个)描述符(8字节)的段基址 
    flush:
         mov cx,00000000000_10_000B         ;加载数据段选择子(0x10)
         mov ds,cx

		 ; // 没有使用段超越前缀, 默认使用当前数据段, 0x000B8000, 即显存的起始地址
         ;以下在屏幕上显示"Protect mode OK." 
         mov byte [0x00],'P'  
         mov byte [0x02],'r'
         mov byte [0x04],'o'
         mov byte [0x06],'t'
         mov byte [0x08],'e'
         mov byte [0x0a],'c'
         mov byte [0x0c],'t'
         mov byte [0x0e],' '
         mov byte [0x10],'m'
         mov byte [0x12],'o'
         mov byte [0x14],'d'
         mov byte [0x16],'e'
         mov byte [0x18],' '
         mov byte [0x1a],'O'
         mov byte [0x1c],'K'

		 ; // 这里的段选择子是 24 ( 索引下标是从 0 开始计算 ), 表示 #3 (每个)描述符(8字节)的段基址 0x00000000
         ;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作 
         mov cx,00000000000_11_000B         ;加载堆栈段选择子
         mov ss,cx
		 ; // 0x007c00, 主引导程序的加载位置
		 ; // 程序中定义的栈空间范围是 0x00007a00 - 0x00007c00 范围, 下面的代码仅仅是验证压入立即数时, ESP是否减4
         mov esp,0x7c00

         mov ebp,esp                        ;保存堆栈指针 
		 ; // 压入立即数, '.' 的 ascii 码
         push byte '.'                      ;压入立即数（字节）
         
         sub ebp,4
         cmp ebp,esp                        ;判断压入立即数时，ESP是否减4 
         jnz ghalt                          
         pop eax
		 ;// 写入显存地址 0x000B8000:0x1e
         mov [0x1e],al                      ;显示句点 
      
  ghalt:     
         hlt                                ;已经禁止中断，将不会被唤醒 

;-------------------------------------------------------------------------------
     
         gdt_size         dw 0
		 ; // 确定从 0x00007e00 处创建全局描述符表 GDT, 最大 64KB,每个描述符 8 字节(64位), 最多可以定义 64KB / 8 字节 = 8192 个描述符
		 ; // 引导程序加载地址是 0x7c00, 主引导扇区 512(0x200) 字节, 0x7c00 + 0x200 = 0x7e00, 换算成 32 位地址是 0x00007e00
         gdt_base         dd 0x00007e00     ;GDT的物理地址 
                             
         times 510-($-$$) db 0
                          db 0x55,0xaa